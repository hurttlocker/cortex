<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Cortex Knowledge Graph</title>
<style>
  :root {
    --bg: #09090b;
    --panel: #0f1013;
    --border: #27272a;
    --text: #f4f4f5;
    --muted: #a1a1aa;
    --accent: #a855f7;
    --accent-dim: #7c3aed;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: var(--bg); color: var(--text); font-family: "SF Pro Display", "Segoe UI", ui-sans-serif, sans-serif; overflow: hidden; }

  .layout { display: flex; height: 100vh; }

  /* ─── Sidebar ─── */
  .sidebar {
    width: 340px; min-width: 340px;
    background: var(--panel);
    border-right: 1px solid var(--border);
    display: flex; flex-direction: column;
    overflow-y: auto;
  }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }

  .brand {
    padding: 18px 16px 14px;
    border-bottom: 1px solid var(--border);
    display: flex; align-items: center; gap: 12px;
    background: linear-gradient(180deg, rgba(168,85,247,0.09), rgba(0,0,0,0));
  }
  .brand-icon {
    width: 40px; height: 40px; object-fit: contain; display: block;
    border-radius: 10px;
    box-shadow: 0 0 0 1px rgba(63,63,70,0.65), 0 10px 25px rgba(0,0,0,0.35);
  }
  .brand-copy { display: flex; flex-direction: column; min-width: 0; }
  .brand-text {
    color: var(--accent);
    font-size: 52px;
    line-height: 0.95;
    letter-spacing: -0.03em;
    font-weight: 800;
  }
  .brand-version {
    font-size: 11px;
    color: var(--muted);
    font-weight: 500;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    margin-top: 4px;
  }

  .section-title {
    font-size: 11px; text-transform: uppercase; letter-spacing: 0.1em;
    color: #71717a; padding: 14px 16px 6px; font-weight: 700;
  }

  .filter-group {
    margin: 0 14px 10px;
    padding: 10px 12px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(24,24,27,0.76), rgba(12,12,14,0.92));
    box-shadow: inset 0 1px 0 rgba(255,255,255,0.02);
  }
  .filter-group label { font-size: 12px; color: var(--muted); display: block; margin-bottom: 4px; }

  .input-row { display: flex; gap: 6px; align-items: center; }
  input[type="text"], input[type="number"], select {
    width: 100%; background: rgba(9,9,11,0.8); border: 1px solid #303036; border-radius: 8px;
    color: var(--text); padding: 8px 10px; font-size: 13px; outline: none;
    transition: border-color 0.15s, box-shadow 0.15s;
  }
  input::placeholder { color: #6b7280; }
  input:focus {
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(168, 85, 247, 0.25);
  }
  select option { background: #0f1013; color: var(--text); }

  .btn {
    padding: 7px 14px; border: 1px solid #303036; border-radius: 8px;
    font-size: 13px; font-weight: 500; cursor: pointer; transition: all 0.15s;
  }
  .btn-primary {
    background: linear-gradient(180deg, #b35cf9, #8b38ef);
    border-color: rgba(196, 134, 255, 0.5);
    color: #fff;
    box-shadow: 0 8px 24px rgba(124, 58, 237, 0.32);
  }
  .btn-primary:hover {
    background: linear-gradient(180deg, #c26bfb, #9644f3);
    box-shadow: 0 10px 28px rgba(124, 58, 237, 0.38);
  }
  .btn-sm { padding: 5px 10px; font-size: 12px; }
  .btn-ghost { background: rgba(18,18,21,0.9); border: 1px solid #303036; color: #b4b4be; }
  .btn-ghost:hover { border-color: var(--accent); color: var(--text); background: rgba(31,31,36,0.96); }
  .btn-full { width: 100%; }
  .btn.active { border-color: var(--accent); color: #fff; background: rgba(168, 85, 247, 0.14); }

  .range-row { display: flex; align-items: center; gap: 8px; }
  .range-row input[type="range"] { flex: 1; accent-color: var(--accent); }
  .range-val { font-size: 12px; color: var(--muted); min-width: 30px; text-align: right; }

  .checkbox-group {
    margin: 0 14px 10px;
    padding: 8px 12px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(24,24,27,0.76), rgba(12,12,14,0.92));
  }
  .checkbox-group label {
    font-size: 13px; color: var(--text); display: flex; align-items: center;
    gap: 6px; cursor: pointer; padding: 3px 0;
  }
  .checkbox-group input { accent-color: var(--accent); }
  .edge-dot { display: inline-block; width: 8px; height: 8px; border-radius: 2px; }

  .type-legend {
    margin: 0 14px 10px;
    padding: 8px 12px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(24,24,27,0.76), rgba(12,12,14,0.92));
  }
  .type-legend .legend-item {
    display: flex; align-items: center; gap: 6px; padding: 2px 0; font-size: 12px; color: var(--muted);
  }
  .legend-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; }

  .mode-switch {
    display: flex; gap: 6px;
  }
  .mode-switch .btn { flex: 1; }
  .mode-note {
    margin-top: 8px; font-size: 12px; color: var(--muted); line-height: 1.4;
    border: 1px solid #303036; border-radius: 8px; padding: 8px 10px;
    background: rgba(9,9,11,0.55);
  }
  .quality-panel {
    margin: 0 14px 10px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(24,24,27,0.76), rgba(12,12,14,0.92));
    padding: 10px 12px;
    font-size: 12px;
    color: var(--muted);
    line-height: 1.5;
  }
  .quality-row {
    display: flex; justify-content: space-between; gap: 10px;
  }
  .quality-key { color: #a1a1aa; }
  .quality-val { color: var(--text); text-align: right; }
  .quality-divider {
    height: 1px; margin: 8px 0; background: rgba(63,63,70,0.5);
  }
  .edge-type-list {
    display: flex; flex-wrap: wrap; gap: 6px;
  }
  .edge-pill {
    display: inline-flex; align-items: center; gap: 6px;
    border: 1px solid #2a2a2e; border-radius: 999px;
    padding: 3px 8px; font-size: 11px; color: #c4c4cc;
    background: rgba(24,24,27,0.75);
  }
  .edge-pill b { color: #f4f4f5; font-weight: 700; }
  .cluster-panel {
    padding: 10px 12px;
  }
  .cluster-summary {
    font-size: 12px;
    color: var(--muted);
    margin-bottom: 8px;
    line-height: 1.4;
  }
  .cluster-list {
    display: flex;
    flex-direction: column;
    gap: 6px;
    max-height: 210px;
    overflow-y: auto;
    padding-right: 2px;
  }
  .cluster-item {
    width: 100%;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    border: 1px solid #2a2a2e;
    border-radius: 10px;
    background: rgba(12,12,14,0.82);
    color: var(--text);
    padding: 8px 9px;
    text-align: left;
    cursor: pointer;
    transition: border-color 0.12s, background 0.12s;
  }
  .cluster-item:hover {
    border-color: #4c1d95;
    background: rgba(22,18,30,0.9);
  }
  .cluster-item.active {
    border-color: var(--accent);
    background: rgba(74,29,150,0.28);
  }
  .cluster-left {
    display: flex;
    align-items: center;
    gap: 8px;
    min-width: 0;
  }
  .cluster-dot {
    width: 9px;
    height: 9px;
    border-radius: 50%;
    flex-shrink: 0;
  }
  .cluster-name {
    font-size: 12px;
    font-weight: 600;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 135px;
  }
  .cluster-meta {
    display: flex;
    align-items: center;
    gap: 6px;
    flex-shrink: 0;
    font-size: 11px;
  }
  .cluster-count {
    color: #a1a1aa;
  }
  .cohesion-badge {
    border-radius: 999px;
    border: 1px solid rgba(63,63,70,0.8);
    padding: 2px 6px;
    font-weight: 700;
  }
  .cohesion-high {
    color: #34d399;
    border-color: rgba(52,211,153,0.45);
    background: rgba(16,185,129,0.15);
  }
  .cohesion-mid {
    color: #fbbf24;
    border-color: rgba(251,191,36,0.45);
    background: rgba(245,158,11,0.14);
  }
  .cohesion-low {
    color: #f87171;
    border-color: rgba(248,113,113,0.45);
    background: rgba(239,68,68,0.14);
  }
  .cluster-empty {
    font-size: 12px;
    color: var(--muted);
    border: 1px dashed #303036;
    border-radius: 10px;
    padding: 9px 10px;
    background: rgba(10,10,12,0.65);
  }

  /* ─── Detail Panel ─── */
  .detail-panel {
    margin: 0 14px 16px;
    padding: 12px;
    border: 1px solid var(--border);
    border-radius: 12px;
    background: linear-gradient(180deg, rgba(24,24,27,0.76), rgba(12,12,14,0.92));
    font-size: 13px; flex: 1; overflow-y: auto; min-height: 120px;
  }
  .detail-panel .fact-id { color: var(--accent); font-weight: 600; font-size: 15px; margin-bottom: 8px; }
  .detail-row { display: flex; padding: 3px 0; gap: 8px; }
  .detail-label { color: var(--muted); min-width: 80px; font-size: 12px; }
  .detail-value { color: var(--text); font-size: 13px; word-break: break-word; }
  .detail-badge {
    display: inline-block; padding: 2px 8px; border-radius: 4px;
    font-size: 11px; font-weight: 600; background: rgba(168, 85, 247, 0.15); color: var(--accent);
  }
  .detail-actions { margin-top: 10px; display: flex; gap: 6px; }

  /* ─── Browse Panel ─── */
  .browse-results {
    max-height: 220px;
    overflow-y: auto;
    margin-top: 8px;
    border: 1px solid var(--border);
    border-radius: 10px;
    background: rgba(8,8,10,0.92);
    box-shadow: 0 14px 36px rgba(0,0,0,0.35);
  }
  .browse-item {
    padding: 8px 10px; border-bottom: 1px solid var(--border); cursor: pointer;
    font-size: 12px; transition: color 0.1s, background 0.1s;
  }
  .browse-item:hover { color: var(--accent); background: rgba(168,85,247,0.08); }
  .browse-item:last-child { border-bottom: none; }
  .browse-item .bi-id { color: var(--accent); font-weight: 600; }
  .browse-item .bi-text { color: #8b8b96; }

  /* ─── Graph Container ─── */
  .canvas { flex: 1; position: relative; background: var(--bg); overflow: hidden; }
  .label-layer {
    position: absolute; inset: 0; pointer-events: none; z-index: 6;
  }
  .node-label {
    position: absolute; transform: translate(-50%, -118%);
    font-size: 11px; line-height: 1; font-weight: 600;
    color: #d4d4d8; background: rgba(10,10,10,0.7);
    border: 1px solid rgba(63,63,70,0.7);
    border-radius: 4px; padding: 3px 6px; white-space: nowrap;
    max-width: 220px; overflow: hidden; text-overflow: ellipsis;
  }
  .node-label.selected {
    color: #fff; border-color: rgba(161,161,170,0.9); background: rgba(24,24,27,0.88);
  }

  /* ─── Stats Bar ─── */
  .stats-bar {
    position: absolute; bottom: 16px; left: 16px;
    background: rgba(12,12,14,0.9); border: 1px solid var(--border); border-radius: 12px;
    padding: 10px 16px; font-size: 12px; color: var(--muted);
    display: none; gap: 20px; backdrop-filter: blur(8px); z-index: 10;
    box-shadow: 0 12px 24px rgba(0,0,0,0.35);
  }
  .stats-bar .stat-val { color: var(--text); font-weight: 600; }
  .impact-seg {
    display: inline-flex; align-items: center; gap: 5px;
    border-radius: 999px; padding: 5px 9px; border: 1px solid transparent;
    font-weight: 600; letter-spacing: 0.02em;
  }
  .impact-seg.high { background: rgba(16,185,129,0.18); color: #34d399; border-color: rgba(16,185,129,0.45); }
  .impact-seg.medium { background: rgba(234,179,8,0.18); color: #facc15; border-color: rgba(234,179,8,0.45); }
  .impact-seg.low { background: rgba(239,68,68,0.18); color: #f87171; border-color: rgba(239,68,68,0.45); }
  .impact-panel-note { color: var(--muted); font-size: 12px; margin-bottom: 8px; line-height: 1.35; }
  .impact-chip {
    display: inline-flex; align-items: center; margin: 3px 4px 0 0;
    border: 1px solid #313138; border-radius: 999px; padding: 4px 9px;
    font-size: 11px; color: #e4e4e7; background: rgba(18,18,22,0.95); cursor: pointer;
  }
  .impact-chip:hover { border-color: var(--accent); color: #fff; }
  .impact-group { border: 1px solid rgba(63,63,70,0.6); border-radius: 8px; margin-top: 8px; background: rgba(7,7,10,0.7); }
  .impact-group summary {
    list-style: none; cursor: pointer; padding: 7px 10px;
    display: flex; align-items: center; justify-content: space-between; gap: 6px;
    font-size: 12px; color: #e4e4e7;
  }
  .impact-group summary::-webkit-details-marker { display: none; }
  .impact-group-meta { color: var(--muted); font-size: 11px; font-weight: 500; }
  .impact-fact-list { padding: 0 8px 8px; }
  .impact-fact {
    width: 100%; margin-top: 6px; text-align: left;
    border: 1px solid #2d2d33; border-radius: 7px; padding: 7px 8px;
    background: rgba(17,17,21,0.95); color: #f4f4f5; cursor: pointer;
    font-size: 11px;
  }
  .impact-fact.high { border-color: rgba(16,185,129,0.55); }
  .impact-fact.medium { border-color: rgba(234,179,8,0.55); }
  .impact-fact.low { border-color: rgba(239,68,68,0.55); }
  .impact-fact:hover { border-color: var(--accent); }
  .impact-fact-sub { color: var(--muted); margin-top: 4px; font-size: 10px; }

  /* ─── Controls Help ─── */
  .controls-help {
    position: absolute; top: 16px; right: 16px;
    background: rgba(12,12,14,0.88); border: 1px solid var(--border); border-radius: 12px;
    padding: 10px 14px; font-size: 11px; color: var(--muted); line-height: 1.6;
    backdrop-filter: blur(8px); z-index: 10;
    box-shadow: 0 16px 34px rgba(0,0,0,0.34);
  }
  .controls-help kbd {
    background: #222; padding: 1px 5px; border-radius: 3px; font-size: 10px;
    border: 1px solid #333; color: var(--text);
  }

  /* ─── Loading / Empty States ─── */
  .center-msg {
    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    text-align: center; z-index: 50; pointer-events: none;
  }
  .center-msg .msg-icon { font-size: 48px; margin-bottom: 12px; opacity: 0.5; }
  .center-msg .msg-icon-img {
    width: 72px; height: 72px; object-fit: contain;
    display: block; margin: 0 auto 12px; opacity: 0.8;
  }
  .center-msg .msg-title { font-size: 16px; color: var(--text); margin-bottom: 6px; }
  .center-msg .msg-sub { font-size: 13px; color: var(--muted); max-width: 320px; }

  .spinner {
    width: 28px; height: 28px; border: 3px solid var(--border);
    border-top-color: var(--accent); border-radius: 50%;
    animation: spin 0.8s linear infinite; margin: 0 auto 12px;
  }
  .timeline-canvas {
    position: absolute;
    inset: 0;
    display: none;
    z-index: 4;
    pointer-events: auto;
  }
  .timeline-tooltip {
    position: absolute;
    pointer-events: none;
    min-width: 220px;
    max-width: 360px;
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid rgba(82, 82, 91, 0.8);
    background: rgba(10, 10, 12, 0.95);
    color: #f4f4f5;
    font-size: 12px;
    line-height: 1.45;
    box-shadow: 0 10px 28px rgba(0, 0, 0, 0.45);
    display: none;
    z-index: 30;
    transform: translate(10px, -8px);
  }
  .timeline-tooltip .tt-sub {
    color: #a1a1aa;
    font-size: 11px;
    margin-top: 4px;
  }
  .timeline-axes text,
  .timeline-lanes text {
    fill: #a1a1aa;
    font-size: 11px;
  }
  .timeline-lanes line {
    stroke: rgba(63, 63, 70, 0.55);
  }
  .timeline-grid line {
    stroke: rgba(63, 63, 70, 0.35);
  }
  .timeline-transition {
    fill: none;
    opacity: 0.9;
  }
  .timeline-node {
    cursor: pointer;
    stroke: rgba(9, 9, 11, 0.9);
    stroke-width: 1.4px;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>
</head>
<body>
<div class="layout">
  <div class="sidebar">
    <div class="brand">
      <img src="/assets/cortex-icon-192.png" class="brand-icon" alt="Cortex logo" />
      <div class="brand-copy">
        <span class="brand-text">Cortex</span>
        <span class="brand-version">Graph Explorer</span>
      </div>
    </div>

    <!-- View Mode -->
    <div class="section-title">View Mode</div>
    <div class="filter-group">
      <div class="mode-switch">
        <button class="btn btn-ghost active" id="modeClusterBtn" onclick="switchToCluster()">Cluster</button>
        <button class="btn btn-ghost" id="modeFactBtn" onclick="switchToFact()">Fact</button>
        <button class="btn btn-ghost" id="modeSubjectBtn" onclick="switchToSubject()">Subject</button>
        <button class="btn btn-ghost" id="modeImpactBtn" onclick="switchToImpact()">Impact</button>
        <button class="btn btn-ghost" id="modeTimelineBtn" onclick="switchToTimeline()">Timeline</button>
      </div>
      <div class="mode-note" id="modeNote">Cluster mode shows high-value subject groups across your graph.</div>
    </div>

    <!-- Cluster Explorer -->
    <div class="section-title">Topic Clusters</div>
    <div class="filter-group cluster-panel">
      <div class="cluster-summary" id="clusterSummary">Loading cluster communities…</div>
      <div class="cluster-list" id="clusterList"></div>
    </div>

    <!-- Search -->
    <div class="section-title">Search Facts</div>
    <div class="filter-group">
      <div class="input-row">
        <input type="text" id="searchInput" name="search" aria-label="Search facts" placeholder="Search by subject, predicate, object..." />
      </div>
      <div class="browse-results" id="browseResults" style="display:none"></div>
    </div>

    <!-- Root Fact -->
    <div class="section-title">Explore From</div>
    <div class="filter-group">
      <label for="factIdInput">Fact ID + Depth</label>
      <div class="input-row">
        <input type="number" id="factIdInput" name="fact_id" aria-label="Fact ID" placeholder="Fact ID" style="width:110px" />
        <input type="range" id="depthSlider" aria-label="Graph depth" min="1" max="5" value="2" style="flex:1" />
        <span class="range-val" id="depthValue">2</span>
      </div>
      <div style="display:flex;gap:6px;margin-top:8px">
        <button class="btn btn-primary" style="flex:1" onclick="loadGraph()">Load Graph</button>
        <button class="btn btn-ghost" style="flex:1" onclick="loadCluster()">Explore Clusters</button>
      </div>
    </div>

    <!-- Timeline -->
    <div class="section-title">Timeline</div>
    <div class="filter-group">
      <label for="timelineSubject">Subject</label>
      <div class="input-row" style="margin-bottom:8px">
        <input type="text" id="timelineSubject" name="timeline_subject" aria-label="Timeline subject" placeholder="e.g. trading" />
      </div>
      <label for="timelineFrom">Date Range</label>
      <div class="input-row" style="margin-bottom:8px">
        <input type="date" id="timelineFrom" aria-label="Timeline from date" />
        <input type="date" id="timelineTo" aria-label="Timeline to date" />
      </div>
      <label for="timelineBucket">Bucket</label>
      <div class="input-row" style="margin-bottom:8px">
        <select id="timelineBucket" aria-label="Timeline bucket">
          <option value="day">Day</option>
          <option value="week">Week</option>
          <option value="month">Month</option>
        </select>
      </div>
      <div style="display:flex;gap:6px">
        <button class="btn btn-primary btn-full" onclick="loadTimeline()">Load Timeline</button>
      </div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;margin-top:8px;font-size:12px;color:var(--muted)">
        <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="timelineShowTransitions" checked /> Transitions</label>
        <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="timelineShowTrend" checked /> Confidence Trend</label>
        <label style="display:flex;align-items:center;gap:6px"><input type="checkbox" id="timelineShowRelated" checked /> Related Lanes</label>
      </div>
    </div>

    <!-- Confidence -->
    <div class="section-title">Filters</div>
    <div class="filter-group">
      <label for="confSlider">Min Confidence</label>
      <div class="range-row">
        <input type="range" id="confSlider" aria-label="Minimum confidence" min="0" max="100" value="0" />
        <span class="range-val" id="confValue">0%</span>
      </div>
      <label for="timeWindow" style="margin-top:8px">Time Window</label>
      <select id="timeWindow" aria-label="Time window">
        <option value="all">All time</option>
        <option value="today">Today</option>
        <option value="week">This week</option>
        <option value="month">This month</option>
      </select>
    </div>

    <!-- Edge Types -->
    <div class="section-title">Edge Types</div>
    <div class="checkbox-group" id="edgeToggles">
      <label><input type="checkbox" name="edge_supports" checked data-type="supports" /> <span class="edge-dot" style="background:#10b981"></span> Supports</label>
      <label><input type="checkbox" name="edge_contradicts" checked data-type="contradicts" /> <span class="edge-dot" style="background:#ef4444"></span> Contradicts</label>
      <label><input type="checkbox" name="edge_relates_to" checked data-type="relates_to" /> <span class="edge-dot" style="background:#3b82f6"></span> Relates To</label>
      <label><input type="checkbox" name="edge_supersedes" checked data-type="supersedes" /> <span class="edge-dot" style="background:#f59e0b"></span> Supersedes</label>
      <label><input type="checkbox" name="edge_derived_from" checked data-type="derived_from" /> <span class="edge-dot" style="background:#6b7280"></span> Derived From</label>
    </div>

    <!-- Display -->
    <div class="section-title">Display</div>
    <div class="checkbox-group">
      <label><input type="checkbox" id="showCoocs" name="show_cooccurrences" /> Co-occurrences</label>
      <label><input type="checkbox" id="showLabels" name="show_labels" checked /> Node Labels</label>
      <label><input type="checkbox" id="showArrows" name="show_arrows" checked /> Directional Arrows</label>
      <label><input type="checkbox" id="impactConcentric" name="impact_concentric" checked /> Concentric impact rings</label>
    </div>

    <!-- Graph Quality -->
    <div class="section-title">Graph Quality</div>
    <div class="quality-panel" id="qualityPanel">
      <div class="quality-row"><span class="quality-key">Status</span><span class="quality-val">Waiting for graph data</span></div>
    </div>

    <div class="section-title" id="impactSectionTitle" style="display:none">Impact Analysis</div>
    <div class="detail-panel" id="impactPanel" style="display:none;margin:0 14px 10px;max-height:260px">
      <span style="color:var(--muted);font-size:12px">Impact groups will appear here.</span>
    </div>

    <!-- Node Legend -->
    <div class="section-title">Fact Types</div>
    <div class="type-legend" id="typeLegend"></div>

    <!-- Selected Fact -->
    <div class="section-title">Selected Fact</div>
    <div class="detail-panel" id="detailPanel">
      <span style="color:var(--muted);font-size:13px">Click a node to inspect</span>
    </div>
  </div>

  <!-- Graph -->
  <div class="canvas" id="graphCanvas">
    <div id="graph2DContainer" style="position:absolute;top:0;left:0;width:100%;height:100%;z-index:2"></div>
    <div id="timelineContainer" class="timeline-canvas">
      <div id="timelineTooltip" class="timeline-tooltip"></div>
    </div>
    <div class="label-layer" id="labelLayer"></div>
    <!-- DB Health Banner -->
    <div id="dbBanner" style="position:absolute;top:12px;left:12px;z-index:20;display:flex;gap:10px;flex-wrap:wrap;">
      <div style="background:rgba(10,10,10,0.9);border:1px solid #262626;border-radius:8px;padding:8px 14px;font-size:12px;backdrop-filter:blur(8px);">
        <span style="color:#a1a1aa;">Facts</span> <span id="dbFacts" style="color:#fff;font-weight:700;font-size:16px;margin-left:4px;">—</span>
      </div>
      <div style="background:rgba(10,10,10,0.9);border:1px solid #262626;border-radius:8px;padding:8px 14px;font-size:12px;backdrop-filter:blur(8px);">
        <span style="color:#a1a1aa;">Memories</span> <span id="dbMemories" style="color:#fff;font-weight:700;font-size:16px;margin-left:4px;">—</span>
      </div>
      <div style="background:rgba(10,10,10,0.9);border:1px solid #262626;border-radius:8px;padding:8px 14px;font-size:12px;backdrop-filter:blur(8px);">
        <span style="color:#a1a1aa;">Edges</span> <span id="dbEdges" style="color:#fff;font-weight:700;font-size:16px;margin-left:4px;">—</span>
      </div>
      <div style="background:rgba(10,10,10,0.9);border:1px solid #262626;border-radius:8px;padding:8px 14px;font-size:12px;backdrop-filter:blur(8px);">
        <span style="color:#a1a1aa;">Avg Conf</span> <span id="dbConf" style="color:#10b981;font-weight:700;font-size:16px;margin-left:4px;">—</span>
      </div>
    </div>
    <div class="center-msg" id="emptyState">
      <img src="/assets/cortex-icon-192.png" class="msg-icon msg-icon-img" alt="Cortex logo" />
      <div class="msg-title">Cortex Knowledge Graph</div>
      <div class="msg-sub">Enter a fact ID or search for facts to explore connections, edges, and co-occurrences.</div>
    </div>
    <div class="center-msg" id="loadingState" style="display:none">
      <img src="/assets/cortex-icon-192.png" class="msg-icon msg-icon-img" alt="" />
      <div class="spinner"></div>
      <div class="msg-title">Loading graph...</div>
    </div>
    <div class="stats-bar" id="statsBar">
      <div id="defaultStats" style="display:flex;gap:20px;align-items:center;">
        Nodes: <span class="stat-val" id="statNodes">0</span>
        Edges: <span class="stat-val" id="statEdges">0</span>
        Co-ocs: <span class="stat-val" id="statCoocs">0</span>
      </div>
      <div id="impactStats" style="display:none;align-items:center;gap:8px;"></div>
    </div>
    <div class="controls-help" id="controlsHelp" style="display:none">
      <kbd>Left drag</kbd> Rotate &nbsp; <kbd>Right drag</kbd> Pan &nbsp; <kbd>Scroll</kbd> Zoom<br>
      <kbd>Click</kbd> Select node &nbsp; <kbd>Double-click</kbd> Focus subject &nbsp; <kbd>Hover</kbd> Tooltip
    </div>
  </div>
</div>

<script src="https://unpkg.com/force-graph"></script>
<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
const CLUSTER_LIMIT = 150;
const CLUSTER_DETAIL_LIMIT = 900;
const SUBJECT_DRILL_LIMIT = 120;
const LABEL_MAX_CHARS = 30;

const EDGE_COLORS = {
  supports: '#10b981',
  contradicts: '#ef4444',
  relates_to: '#3b82f6',
  supersedes: '#f59e0b',
  derived_from: '#6b7280',
  cooccurrence: '#3f3f46'
};
const IMPACT_EDGE_COLORS = {
  has_tool: '#22c55e',
  has_config: '#06b6d4',
  has_strategy: '#f97316',
  has_location: '#eab308',
  depends_on: '#ef4444',
  related_to: '#8b5cf6',
  other: '#71717a'
};

const FACT_TYPE_COLORS = {
  kv: '#a855f7',
  temporal: '#06b6d4',
  identity: '#f97316',
  state: '#84cc16',
  preference: '#ec4899',
  decision: '#eab308',
  location: '#14b8a6',
  relationship: '#f43f5e'
};

const SUBJECT_PALETTE = ['#8b5cf6', '#06b6d4', '#22c55e', '#f59e0b', '#ef4444', '#14b8a6', '#eab308', '#3b82f6', '#d946ef'];
const TOGGLE_EDGE_TYPES = new Set(['supports', 'contradicts', 'relates_to', 'supersedes', 'derived_from']);
const MODE_NOTES = {
  cluster: 'Cluster mode shows precomputed topic communities with cohesion scores and drill-down.',
  fact: 'Fact mode expands from one fact ID using inferred or stored relationship edges.',
  subject: 'Subject mode isolates facts for one subject to review its local context.',
  impact: 'Impact mode shows blast radius grouped by relationship and confidence heat.',
  timeline: 'Timeline mode maps how knowledge about a subject evolves through time.'
};
const TIMELINE_TRANSITION_STYLE = {
  superseded: { color: '#ef4444', dash: '7,5' },
  refined: { color: '#10b981', dash: '' },
  decayed: { color: '#9ca3af', dash: '2,6' },
  expanded: { color: '#3b82f6', dash: '' },
  contradicted: { color: '#f43f5e', dash: '5,3' }
};

let Graph = null;
let Graph2D = null;
let graphData = null;
let timelineData = null;
let selectedNode = null;
let searchDebounce = null;
let autoFitPending = false;
let lastNodeClick = { id: null, at: 0 };
let currentViewMode = 'cluster';
let activeSearchNodeIDs = new Set();
let clusterCatalog = [];
let clusterSummary = { total_facts: 0, unclustered_count: 0 };
let activeClusterId = null;
let impactData = null;
let timelineRenderedNodes = [];
const HELP_2D = `
  <kbd>Drag node</kbd> Reposition &nbsp; <kbd>Drag canvas</kbd> Pan &nbsp; <kbd>Scroll</kbd> Zoom<br>
  <kbd>Click</kbd> Select node &nbsp; <kbd>Double-click</kbd> Focus subject &nbsp; <kbd>Hover</kbd> Tooltip
`;
const HELP_TIMELINE = `
  <kbd>Drag</kbd> Pan timeline &nbsp; <kbd>Scroll</kbd> Zoom time axis<br>
  <kbd>Click node</kbd> Inspect fact &nbsp; <kbd>Hover</kbd> Fact tooltip
`;

function truncate(s, n) {
  return s && s.length > n ? s.substring(0, n) + '…' : (s || '');
}

function esc(s) {
  const d = document.createElement('div');
  d.textContent = s || '';
  return d.innerHTML;
}

function dimColor(color, alpha) {
  if (!color) return `rgba(113,113,122,${alpha})`;
  if (color.startsWith('rgba(')) {
    return color.replace(/rgba\(([^)]+),[^)]+\)/, `rgba($1,${alpha})`);
  }
  if (color.startsWith('rgb(')) {
    return color.replace('rgb(', 'rgba(').replace(')', `,${alpha})`);
  }
  if (color.startsWith('#') && (color.length === 7 || color.length === 4)) {
    let hex = color.slice(1);
    if (hex.length === 3) hex = hex.split('').map(ch => ch + ch).join('');
    const n = parseInt(hex, 16);
    const r = (n >> 16) & 255;
    const g = (n >> 8) & 255;
    const b = n & 255;
    return `rgba(${r},${g},${b},${alpha})`;
  }
  return `rgba(113,113,122,${alpha})`;
}

function hashString(s) {
  let h = 0;
  for (let i = 0; i < s.length; i += 1) h = ((h << 5) - h + s.charCodeAt(i)) | 0;
  return Math.abs(h);
}

function subjectColor(subject) {
  if (!subject) return '#71717a';
  return SUBJECT_PALETTE[hashString(subject.toLowerCase()) % SUBJECT_PALETTE.length];
}

function buildTypeLegend() {
  const el = document.getElementById('typeLegend');
  el.innerHTML = Object.entries(FACT_TYPE_COLORS).map(([type, color]) =>
    `<div class="legend-item"><span class="legend-dot" style="background:${color}"></span>${type}</div>`
  ).join('');
}

function edgeTypeName(type) {
  if (!type) return 'unknown';
  return String(type).replace(/_/g, ' ');
}

function edgeColorForType(type) {
  if (currentViewMode === 'impact' && IMPACT_EDGE_COLORS[type]) {
    return IMPACT_EDGE_COLORS[type];
  }
  return EDGE_COLORS[type] || '#71717a';
}

function setViewMode(mode) {
  currentViewMode = mode;
  const ids = ['modeClusterBtn', 'modeFactBtn', 'modeSubjectBtn', 'modeImpactBtn', 'modeTimelineBtn'];
  ids.forEach(id => document.getElementById(id).classList.remove('active'));
  if (mode === 'fact') document.getElementById('modeFactBtn').classList.add('active');
  else if (mode === 'subject') document.getElementById('modeSubjectBtn').classList.add('active');
  else if (mode === 'impact') document.getElementById('modeImpactBtn').classList.add('active');
  else if (mode === 'timeline') document.getElementById('modeTimelineBtn').classList.add('active');
  else document.getElementById('modeClusterBtn').classList.add('active');
  document.getElementById('modeNote').textContent = MODE_NOTES[mode] || MODE_NOTES.cluster;
  document.getElementById('impactSectionTitle').style.display = mode === 'impact' ? 'block' : 'none';
  document.getElementById('impactPanel').style.display = mode === 'impact' ? 'block' : 'none';
  if (mode === 'timeline') setTimelineSpace();
  else setGraphSpace();
}

function setModeNoteTemporary(message) {
  const el = document.getElementById('modeNote');
  el.textContent = message;
  setTimeout(() => {
    el.textContent = MODE_NOTES[currentViewMode] || MODE_NOTES.cluster;
  }, 2600);
}

function cohesionClass(v) {
  const score = Number(v || 0);
  if (score >= 0.7) return 'cohesion-high';
  if (score >= 0.45) return 'cohesion-mid';
  return 'cohesion-low';
}

function renderClusterSidebar() {
  const summaryEl = document.getElementById('clusterSummary');
  const listEl = document.getElementById('clusterList');
  const clusterCount = clusterCatalog.length;

  if (!clusterCount) {
    summaryEl.textContent = `No clusters detected. Unclustered: ${clusterSummary.unclustered_count || 0} / ${clusterSummary.total_facts || 0} facts.`;
    listEl.innerHTML = '<div class=\"cluster-empty\">Run extraction/import and rebuild clusters to populate this view.</div>';
    return;
  }

  summaryEl.textContent = `${clusterCount} clusters • ${(clusterSummary.unclustered_count || 0).toLocaleString()} unclustered / ${(clusterSummary.total_facts || 0).toLocaleString()} facts`;
  listEl.innerHTML = clusterCatalog.map(c => {
    const active = Number(activeClusterId) === Number(c.id) ? 'active' : '';
    const cohesion = Number(c.cohesion || 0);
    return `
      <button class=\"cluster-item ${active}\" onclick=\"loadClusterDetail(${c.id})\">
        <span class=\"cluster-left\">
          <span class=\"cluster-dot\" style=\"background:${c.color || '#71717a'}\"></span>
          <span class=\"cluster-name\">${esc(c.name || `Cluster ${c.id}`)}</span>
        </span>
        <span class=\"cluster-meta\">
          <span class=\"cluster-count\">${Number(c.fact_count || 0).toLocaleString()}</span>
          <span class=\"cohesion-badge ${cohesionClass(cohesion)}\">${cohesion.toFixed(2)}</span>
        </span>
      </button>
    `;
  }).join('');
}

function updateControlsHelp() {
  const help = document.getElementById('controlsHelp');
  help.innerHTML = currentViewMode === 'timeline' ? HELP_TIMELINE : HELP_2D;
}

function setGraphSpace() {
  const container2D = document.getElementById('graph2DContainer');
  const timelineContainer = document.getElementById('timelineContainer');
  const outer = document.getElementById('graphCanvas');
  const w = outer.clientWidth || window.innerWidth - 340;
  const h = outer.clientHeight || window.innerHeight;

  timelineContainer.style.display = 'none';
  container2D.style.display = 'block';
  container2D.style.visibility = 'visible';
  container2D.style.opacity = '1';
  container2D.style.pointerEvents = 'auto';

  if (Graph2D) {
    Graph2D.width(w).height(h);
  }

  document.getElementById('labelLayer').style.display = 'none';
  Graph = Graph2D;
  updateControlsHelp();
  if (graphData) {
    renderGraph();
    const q = document.getElementById('searchInput').value.trim();
    if (q) highlightSearch(q);
  }
}

function setTimelineSpace() {
  const container2D = document.getElementById('graph2DContainer');
  const timelineContainer = document.getElementById('timelineContainer');
  container2D.style.display = 'none';
  container2D.style.visibility = 'hidden';
  container2D.style.opacity = '0';
  container2D.style.pointerEvents = 'none';
  timelineContainer.style.display = 'block';
  document.getElementById('labelLayer').style.display = 'none';
  updateControlsHelp();
}

function todayISODate() {
  return new Date().toISOString().slice(0, 10);
}

function shiftISODate(days) {
  const d = new Date();
  d.setUTCDate(d.getUTCDate() + days);
  return d.toISOString().slice(0, 10);
}

function setTimelineDefaults() {
  if (!document.getElementById('timelineFrom').value) {
    document.getElementById('timelineFrom').value = shiftISODate(-30);
  }
  if (!document.getElementById('timelineTo').value) {
    document.getElementById('timelineTo').value = todayISODate();
  }
}

function switchToCluster() {
  const q = document.getElementById('searchInput').value.trim();
  loadCluster(q);
}

function switchToFact() {
  const idInput = document.getElementById('factIdInput');
  if (!idInput.value.trim() && selectedNode && selectedNode.id) {
    idInput.value = selectedNode.id;
  }
  if (!idInput.value.trim()) {
    setModeNoteTemporary('Enter a Fact ID or pick a search result first.');
    return;
  }
  loadGraph();
}

function switchToSubject() {
  let subject = '';
  if (selectedNode && selectedNode.subject) subject = selectedNode.subject;
  if (!subject) subject = document.getElementById('searchInput').value.trim();
  if (!subject) {
    setModeNoteTemporary('Select a node or type a subject in search first.');
    return;
  }
  loadSubject(subject);
}

function switchToImpact() {
  let subject = '';
  if (selectedNode && selectedNode.subject) subject = selectedNode.subject;
  if (!subject) subject = document.getElementById('searchInput').value.trim();
  if (!subject) {
    setModeNoteTemporary('Type or select a subject to run impact analysis.');
    return;
  }
  loadImpact(subject);
}

function switchToTimeline() {
  let subject = document.getElementById('timelineSubject').value.trim();
  if (!subject && selectedNode && selectedNode.subject) subject = selectedNode.subject;
  if (!subject) subject = document.getElementById('searchInput').value.trim();
  if (!subject) {
    setModeNoteTemporary('Type a timeline subject or select a node first.');
    return;
  }
  loadTimeline(subject);
}

function setQualityStatus(status) {
  const panel = document.getElementById('qualityPanel');
  panel.innerHTML = `<div class="quality-row"><span class="quality-key">Status</span><span class="quality-val">${esc(status)}</span></div>`;
}

function updateQualityPanel(nodes, links) {
  const panel = document.getElementById('qualityPanel');
  const meta = graphData && graphData.meta ? graphData.meta : {};
  const mode = meta.mode || currentViewMode;
  let query = meta.query || '';
  if (!query && currentViewMode === 'subject') {
    query = document.getElementById('searchInput').value.trim();
  } else if (!query && currentViewMode === 'fact') {
    const fid = document.getElementById('factIdInput').value.trim();
    query = fid ? `fact_id=${fid}` : '';
  }

  let edgeMode = meta.edge_mode || '';
  if (!edgeMode) {
    if (currentViewMode === 'fact') edgeMode = 'graph_traversal';
    else if (currentViewMode === 'subject') edgeMode = 'subject_graph';
    else edgeMode = 'cluster_graph';
  }
  const fallbackEdges = Number(meta.fallback_edges || 0);
  const subjectBand = (meta.subject_min_facts && meta.subject_max_facts)
    ? `${meta.subject_min_facts}-${meta.subject_max_facts}`
    : 'n/a';
  const subjectGroups = meta.subjects || 0;
  const realEdges = links.filter(l => !l._isCooc);

  const counts = {};
  for (const edge of links) {
    const t = edge.type || 'unknown';
    counts[t] = (counts[t] || 0) + 1;
  }
  const edgePills = Object.entries(counts)
    .sort((a, b) => b[1] - a[1])
    .map(([type, count]) => `<span class="edge-pill"><span class="edge-dot" style="background:${edgeColorForType(type)}"></span>${esc(edgeTypeName(type))} <b>${count}</b></span>`)
    .join('');

  const density = nodes.length > 0 ? (realEdges.length / nodes.length).toFixed(2) : '0.00';
  const clusterName = meta.cluster_name || (graphData && graphData.cluster ? graphData.cluster.name : '');
  const clusterCohesion = Number(meta.cohesion || (graphData && graphData.cluster ? graphData.cluster.cohesion : 0));
  const clusterFacts = Number((graphData && graphData.cluster ? graphData.cluster.fact_count : meta.total_nodes) || 0);
  const clusterSubjects = (graphData && graphData.cluster && graphData.cluster.top_subjects) ? graphData.cluster.top_subjects.length : subjectGroups;
  const clusterRows = mode === 'cluster_detail' ? `
    <div class="quality-row"><span class="quality-key">Cluster</span><span class="quality-val">${esc(clusterName || '(unknown)')}</span></div>
    <div class="quality-row"><span class="quality-key">Cohesion</span><span class="quality-val">${clusterCohesion.toFixed(2)}</span></div>
    <div class="quality-row"><span class="quality-key">Cluster Facts</span><span class="quality-val">${clusterFacts}</span></div>
    <div class="quality-row"><span class="quality-key">Top Subjects</span><span class="quality-val">${clusterSubjects}</span></div>
  ` : `
    <div class="quality-row"><span class="quality-key">Fallback Edges</span><span class="quality-val">${fallbackEdges}</span></div>
    <div class="quality-row"><span class="quality-key">Subject Band</span><span class="quality-val">${esc(subjectBand)}</span></div>
    <div class="quality-row"><span class="quality-key">Subject Groups</span><span class="quality-val">${subjectGroups}</span></div>
  `;
  panel.innerHTML = `
    <div class="quality-row"><span class="quality-key">View</span><span class="quality-val">${esc(mode)}</span></div>
    <div class="quality-row"><span class="quality-key">Query</span><span class="quality-val">${esc(query || '(none)')}</span></div>
    <div class="quality-row"><span class="quality-key">Edge Source</span><span class="quality-val">${esc(edgeMode)}</span></div>
    ${clusterRows}
    <div class="quality-row"><span class="quality-key">Edge Density</span><span class="quality-val">${density}</span></div>
    <div class="quality-divider"></div>
    <div class="edge-type-list">${edgePills || '<span class="quality-key">No visible edges</span>'}</div>
  `;
}

function nodeColorFor(node) {
  if (selectedNode && node.id === selectedNode.id) return '#ffffff';
  if (currentViewMode === 'cluster') {
    if (node.cluster_color) return node.cluster_color;
    if (node.cluster_id) return subjectColor(String(node.cluster_id));
    return '#71717a';
  }
  if (node.type && node.type !== 'kv' && FACT_TYPE_COLORS[node.type]) return FACT_TYPE_COLORS[node.type];
  return subjectColor(node.subject);
}

function timeCutoffForPreset(preset) {
  const now = Date.now();
  switch (preset) {
    case 'today':
      return now - (24 * 60 * 60 * 1000);
    case 'week':
      return now - (7 * 24 * 60 * 60 * 1000);
    case 'month':
      return now - (30 * 24 * 60 * 60 * 1000);
    default:
      return null;
  }
}

function nodePassesTimeWindow(node, cutoffMs) {
  if (cutoffMs == null) return true;
  if (!node.last_updated) return false;
  const ts = Date.parse(node.last_updated);
  if (Number.isNaN(ts)) return false;
  return ts >= cutoffMs;
}

function shouldRenderLabel(node) {
  if (!document.getElementById('showLabels').checked) return false;
  if (!graphData || !graphData.nodes) return false;
  const total = graphData.nodes.length;
  if (selectedNode && selectedNode.id === node.id) return true;
  if (total > 140) return node.confidence >= 0.8;
  if (total > 90) return node.confidence >= 0.7;
  return true;
}

function buildSubjectStats(nodes) {
  const stats = new Map();
  for (const node of nodes || []) {
    const subject = (node.subject || '').trim();
    if (!subject) continue;
    const key = subject.toLowerCase();
    if (!stats.has(key)) {
      stats.set(key, { count: 1, topID: node.id, topConf: node.confidence || 0 });
      continue;
    }
    const cur = stats.get(key);
    cur.count += 1;
    if ((node.confidence || 0) > cur.topConf) {
      cur.topConf = node.confidence || 0;
      cur.topID = node.id;
    }
  }
  return stats;
}

function humanLabelForNode(node, subjectStats) {
  const fallback = `#${node.id}`;
  const subject = (node.subject || '').trim();
  if (!subject) return fallback;
  const stat = subjectStats.get(subject.toLowerCase());
  if (!stat || stat.count <= 1) return truncate(subject, LABEL_MAX_CHARS);
  if (node.id === stat.topID) return truncate(subject, LABEL_MAX_CHARS);

  const predicate = (node.predicate || '').trim();
  if (predicate) return truncate(`-> ${predicate}`, LABEL_MAX_CHARS + 8);

  const object = (node.object || '').trim();
  if (object) return truncate(`-> ${object}`, LABEL_MAX_CHARS + 8);

  return truncate(`${subject} ${fallback}`, LABEL_MAX_CHARS + 4);
}

function drawLabelOverlay() {
  document.getElementById('labelLayer').innerHTML = '';
}

function updateGraphStyling() {
  const showArrows = document.getElementById('showArrows').checked;
  const showLabels = document.getElementById('showLabels').checked;
  const query = (document.getElementById('searchInput').value || '').trim().toLowerCase();
  const hasSearch = query.length >= 2;

  if (Graph2D) {
    const nodes2D = Graph2D.graphData()?.nodes || [];
    const subjectStats = buildSubjectStats(nodes2D);
    const impactRoot = impactData && impactData.subject ? String(impactData.subject).toLowerCase() : '';
    Graph2D.nodeColor(n => {
      let base = nodeColorFor(n);
      if (currentViewMode === 'impact') {
        const alpha = Math.max(0.25, Math.min(1, n.confidence || 0));
        base = dimColor(base, alpha);
        if (impactRoot && (n.subject || '').toLowerCase() === impactRoot) {
          base = '#ffffff';
        }
      }
      if (!hasSearch) return base;
      if (activeSearchNodeIDs.size > 0) {
        return activeSearchNodeIDs.has(n.id) ? '#ffffff' : dimColor(base, 0.2);
      }
      const text = `${n.subject || ''} ${n.predicate || ''} ${n.object || ''}`.toLowerCase();
      return text.includes(query) ? '#ffffff' : dimColor(base, 0.2);
    });
    Graph2D.nodeVal(n => {
      let v = 0.95 + (n.confidence || 0) * 2.4;
      if (currentViewMode === 'impact') {
        v *= 0.85 + (n.confidence || 0);
        if (impactRoot && (n.subject || '').toLowerCase() === impactRoot) {
          v *= 1.9;
        }
      }
      if (hasSearch && activeSearchNodeIDs.has(n.id)) v *= 1.75;
      return v;
    });
    Graph2D.linkLabel(link => {
      if (link._isCooc) return `Co-occurrence: ${link.count || 1}`;
      const predicate = link.label ? ` • ${link.label}` : '';
      return `${edgeTypeName(link.type)}${predicate}`;
    });
    Graph2D.linkDirectionalArrowLength(link => {
      if (link._isCooc) return 0;
      return showArrows ? 3 : 0;
    });
    Graph2D.nodeCanvasObjectMode(() => 'after');
    Graph2D.nodeCanvasObject((node, ctx, globalScale) => {
      if (!showLabels || !shouldRenderLabel(node)) return;
      const label = humanLabelForNode(node, subjectStats);
      const fontSize = Math.max(10 / globalScale, 8);
      ctx.font = `${fontSize}px system-ui, -apple-system, sans-serif`;
      const textW = ctx.measureText(label).width;
      const pad = 3 / globalScale;
      const boxW = textW + pad * 2;
      const boxH = fontSize + pad * 2;
      const x = node.x - boxW / 2;
      const y = node.y - 10 / globalScale - boxH;
      ctx.fillStyle = 'rgba(10,10,10,0.78)';
      ctx.strokeStyle = 'rgba(82,82,91,0.72)';
      ctx.lineWidth = 1 / globalScale;
      ctx.beginPath();
      ctx.rect(x, y, boxW, boxH);
      ctx.fill();
      ctx.stroke();
      ctx.fillStyle = selectedNode && selectedNode.id === node.id ? '#ffffff' : '#d4d4d8';
      ctx.fillText(label, x + pad, y + boxH - pad - 1 / globalScale);
    });
  }
  drawLabelOverlay();
}

function showLoading(message) {
  document.getElementById('emptyState').style.display = 'none';
  document.getElementById('loadingState').style.display = 'block';
  document.querySelector('#loadingState .msg-title').textContent = message || 'Loading graph...';
  document.getElementById('controlsHelp').style.display = 'none';
  document.getElementById('statsBar').style.display = 'none';
  document.getElementById('labelLayer').innerHTML = '';
  document.getElementById('timelineTooltip').style.display = 'none';
  setQualityStatus(message || 'Loading graph...');
}

function showEmpty(title, subtitle) {
  document.getElementById('loadingState').style.display = 'none';
  document.getElementById('emptyState').style.display = 'block';
  document.querySelector('#emptyState .msg-title').textContent = title;
  document.querySelector('#emptyState .msg-sub').textContent = subtitle;
  document.getElementById('controlsHelp').style.display = 'none';
  document.getElementById('statsBar').style.display = 'none';
  document.getElementById('labelLayer').innerHTML = '';
  document.getElementById('timelineTooltip').style.display = 'none';
  setQualityStatus(title || 'No graph data');
}

function formatNodeTooltip(n) {
  return `#${n.id}: ${n.subject}\n${n.predicate}: ${truncate(n.object, 120)}\nType: ${n.type || 'unknown'} | Conf: ${(n.confidence * 100).toFixed(0)}%${n.agent_id ? `\nAgent: ${n.agent_id}` : ''}`;
}

function handleNodeClick(node) {
  const now = Date.now();
  const isDoubleClick = lastNodeClick.id === node.id && now - lastNodeClick.at < 420;
  lastNodeClick = { id: node.id, at: now };

  selectedNode = node;
  showDetail(node);
  updateGraphStyling();

  if (Graph2D && Number.isFinite(node.x) && Number.isFinite(node.y)) {
    Graph2D.centerAt(node.x, node.y, 700);
    Graph2D.zoom(2.8, 700);
  }

  if (isDoubleClick) loadSubject(node.subject);
}

function initGraph() {
  const outer = document.getElementById('graphCanvas');
  const container2D = document.getElementById('graph2DContainer');
  const w = outer.clientWidth || window.innerWidth - 340;
  const h = outer.clientHeight || window.innerHeight;

  Graph2D = ForceGraph()(container2D)
    .backgroundColor('#07080d')
    .width(w)
    .height(h)
    .nodeRelSize(5.4)
    .nodeVal(n => 0.95 + (n.confidence || 0) * 2.4)
    .nodeColor(nodeColorFor)
    .nodeLabel(formatNodeTooltip)
    .linkColor(link => edgeColorForType(link.type))
    .linkWidth(link => {
      if (link._isCooc) return 0.6 + Math.min((link.count || 1) / 10, 2.6);
      return 0.95 + Math.min((link.confidence || 0.1) * 2.2, 2.8);
    })
    .linkDirectionalArrowLength(link => {
      if (link._isCooc) return 0;
      return document.getElementById('showArrows').checked ? 3 : 0;
    })
    .linkDirectionalArrowRelPos(1)
    .linkDirectionalArrowColor(link => edgeColorForType(link.type))
    .d3AlphaDecay(0.06)
    .d3VelocityDecay(0.38)
    .onNodeClick(node => handleNodeClick(node))
    .onNodeDragEnd(node => {
      node.fx = node.x;
      node.fy = node.y;
    })
    .onBackgroundClick(() => {
      selectedNode = null;
      updateGraphStyling();
      document.getElementById('detailPanel').innerHTML = '<span style="color:var(--muted);font-size:13px">Click a node to inspect</span>';
    })
    .onNodeHover(node => {
      container2D.style.cursor = node ? 'pointer' : 'default';
    });

  Graph = Graph2D;
  setGraphSpace();

  window.addEventListener('resize', () => {
    const nw = outer.clientWidth || window.innerWidth - 340;
    const nh = outer.clientHeight || window.innerHeight;
    if (Graph2D) Graph2D.width(nw).height(nh);
    if (currentViewMode === 'timeline' && timelineData) renderTimeline();
  });
}

async function loadGraph() {
  const factId = document.getElementById('factIdInput').value.trim();
  if (!factId) return;

  setViewMode('fact');
  impactData = null;
  const depth = document.getElementById('depthSlider').value;
  showLoading('Loading graph...');

  try {
    const resp = await fetch(`/api/graph?fact_id=${encodeURIComponent(factId)}&depth=${depth}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    graphData = await resp.json();
    selectedNode = null;
    autoFitPending = true;

    if (!graphData.nodes || graphData.nodes.length === 0) {
      showEmpty(
        'No graph data',
        `Fact #${factId} has no connected relationships yet. Try running "cortex infer" to generate relationship edges.`
      );
      return;
    }

    renderGraph();
  } catch (err) {
    showEmpty('Error', err.message);
  }
}

async function loadSubject(subject) {
  const value = (subject || '').trim();
  if (!value) return;

  setViewMode('subject');
  impactData = null;
  showLoading(`Loading subject: ${value}`);
  document.getElementById('searchInput').value = value;
  hideBrowseResults();

  try {
    const minConf = parseInt(document.getElementById('confSlider').value, 10) / 100;
    const resp = await fetch(`/api/graph?subject=${encodeURIComponent(value)}&limit=${SUBJECT_DRILL_LIMIT}&min_confidence=${minConf}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    graphData = await resp.json();
    selectedNode = null;
    autoFitPending = true;

    if (!graphData.nodes || graphData.nodes.length === 0) {
      showEmpty('No facts for subject', `No active facts found for "${value}".`);
      return;
    }

    renderGraph();
  } catch (err) {
    showEmpty('Error', err.message);
  }
}

function impactConfidenceClass(conf) {
  if (conf >= 0.8) return 'high';
  if (conf >= 0.5) return 'medium';
  return 'low';
}

function renderImpactPanel(data) {
  const panel = document.getElementById('impactPanel');
  if (!data || !data.groups) {
    panel.innerHTML = '<span style="color:var(--muted);font-size:12px">Impact groups unavailable.</span>';
    return;
  }

  const chips = (data.connected_subjects || []).slice(0, 24).map(subj =>
    `<button class="impact-chip" onclick='loadImpact(${JSON.stringify(subj)})'>${esc(subj)}</button>`
  ).join('');

  const groupsHTML = (data.groups || []).map(g => {
    const rel = esc(edgeTypeName(g.relationship || 'other'));
    const avgPct = ((g.avg_confidence || 0) * 100).toFixed(0);
    const facts = (g.facts || []).slice(0, 30).map(f => {
      const confClass = impactConfidenceClass(f.confidence || 0);
      const label = `${f.subject || ''} ${f.predicate || ''} ${truncate(f.object || '', 70)}`;
      return `<button class="impact-fact ${confClass}" onclick="focusNodeById(${f.id})">
        <div>${esc(label)}</div>
        <div class="impact-fact-sub">${((f.confidence || 0) * 100).toFixed(0)}% confidence · ${f.connected_count || 0} links · depth ${f.depth || 0}</div>
      </button>`;
    }).join('');

    return `<details class="impact-group" open>
      <summary>
        <span>${rel}</span>
        <span class="impact-group-meta">${g.fact_count || 0} facts · avg ${avgPct}%</span>
      </summary>
      <div class="impact-fact-list">${facts || '<div class="impact-panel-note">No facts in this group.</div>'}</div>
    </details>`;
  }).join('');

  panel.innerHTML = `
    <div class="impact-panel-note">
      Subject <b>${esc(data.subject || '')}</b> · ${data.total_facts || 0} facts · depth ${data.depth || 0}
    </div>
    <div class="impact-panel-note" style="margin-top:2px;margin-bottom:6px;">
      Connected subjects:
    </div>
    <div>${chips || '<span class="impact-panel-note">No connected subjects.</span>'}</div>
    ${groupsHTML || '<div class="impact-panel-note" style="margin-top:8px;">No relationship groups found.</div>'}
  `;
}

function updateStatsBar(nodes, links) {
  const defaultStats = document.getElementById('defaultStats');
  const impactStats = document.getElementById('impactStats');
  if (currentViewMode === 'impact' && impactData && impactData.confidence_distribution) {
    defaultStats.style.display = 'none';
    impactStats.style.display = 'flex';
    const d = impactData.confidence_distribution || {};
    impactStats.innerHTML = `
      <span class="impact-seg high">HIGH ${d.high || 0}</span>
      <span class="impact-seg medium">MED ${d.medium || 0}</span>
      <span class="impact-seg low">LOW ${d.low || 0}</span>
    `;
    return;
  }

  defaultStats.style.display = 'flex';
  impactStats.style.display = 'none';
  impactStats.innerHTML = '';
  document.getElementById('statNodes').textContent = nodes.length;
  document.getElementById('statEdges').textContent = links.filter(l => !l._isCooc).length;
  document.getElementById('statCoocs').textContent = links.filter(l => l._isCooc).length;
}

function applyImpactConcentricLayout() {
  if (!Graph2D || currentViewMode !== 'impact') return;
  if (!document.getElementById('impactConcentric').checked) return;

  const runtime = Graph2D.graphData();
  if (!runtime || !runtime.nodes || runtime.nodes.length === 0) return;

  const rootSubj = impactData && impactData.subject ? String(impactData.subject).toLowerCase() : '';
  const depthGroups = new Map();
  for (const node of runtime.nodes) {
    const d = Math.max(0, Number.isFinite(node.depth) ? node.depth : 0);
    if (!depthGroups.has(d)) depthGroups.set(d, []);
    depthGroups.get(d).push(node);
  }

  const ringStep = 140;
  for (const [depth, list] of depthGroups.entries()) {
    list.sort((a, b) => {
      if ((a.subject || '').toLowerCase() === rootSubj && (b.subject || '').toLowerCase() !== rootSubj) return -1;
      if ((b.subject || '').toLowerCase() === rootSubj && (a.subject || '').toLowerCase() !== rootSubj) return 1;
      return a.id - b.id;
    });

    const radius = depth === 0 ? (list.length > 1 ? 34 : 0) : depth * ringStep;
    const total = list.length;
    for (let i = 0; i < total; i += 1) {
      const angle = total === 1 ? 0 : (2 * Math.PI * i) / total;
      list[i].fx = Math.cos(angle) * radius;
      list[i].fy = Math.sin(angle) * radius;
    }
  }

  Graph2D.d3ReheatSimulation();
}

async function loadImpact(subject) {
  const value = (subject || '').trim();
  if (!value) return;

  setViewMode('impact');
  showLoading(`Running impact analysis: ${value}`);
  document.getElementById('searchInput').value = value;
  hideBrowseResults();

  try {
    const depth = document.getElementById('depthSlider').value || '3';
    const minConf = parseInt(document.getElementById('confSlider').value, 10) / 100;
    const resp = await fetch(`/api/impact?subject=${encodeURIComponent(value)}&depth=${encodeURIComponent(depth)}&min_confidence=${minConf}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

    impactData = await resp.json();
    selectedNode = null;
    autoFitPending = true;
    renderImpactPanel(impactData);

    graphData = {
      nodes: impactData.nodes || [],
      edges: impactData.edges || [],
      cooccurrences: [],
      meta: impactData.meta || { mode: 'impact', subject: value }
    };

    if (!graphData.nodes || graphData.nodes.length === 0) {
      showEmpty('No impact facts', `No connected facts found for "${value}".`);
      return;
    }

    renderGraph();
  } catch (err) {
    showEmpty('Error', err.message);
  }
function parseISODateUTC(raw) {
  const value = (raw || '').trim();
  if (!value) return null;
  const d = new Date(`${value}T00:00:00Z`);
  if (Number.isNaN(d.getTime())) return null;
  return d;
}

function updateTimelineQualityPanel(payload, facts, transitions, lanes) {
  const panel = document.getElementById('qualityPanel');
  const range = payload?.range || {};
  panel.innerHTML = `
    <div class="quality-row"><span class="quality-key">View</span><span class="quality-val">timeline</span></div>
    <div class="quality-row"><span class="quality-key">Subject</span><span class="quality-val">${esc(payload?.subject || '—')}</span></div>
    <div class="quality-row"><span class="quality-key">Range</span><span class="quality-val">${esc((range.from || '—') + ' → ' + (range.to || '—'))}</span></div>
    <div class="quality-row"><span class="quality-key">Bucket</span><span class="quality-val">${esc(payload?.bucket || 'day')}</span></div>
    <div class="quality-row"><span class="quality-key">Buckets</span><span class="quality-val">${(payload?.buckets || []).length}</span></div>
    <div class="quality-row"><span class="quality-key">Facts</span><span class="quality-val">${facts.length}</span></div>
    <div class="quality-row"><span class="quality-key">Transitions</span><span class="quality-val">${transitions.length}</span></div>
    <div class="quality-row"><span class="quality-key">Lanes</span><span class="quality-val">${lanes.length}</span></div>
  `;
}

function showTimelineTooltip(event, fact) {
  const tooltip = document.getElementById('timelineTooltip');
  const canvasRect = document.getElementById('graphCanvas').getBoundingClientRect();
  tooltip.style.display = 'block';
  tooltip.style.left = `${event.clientX - canvasRect.left}px`;
  tooltip.style.top = `${event.clientY - canvasRect.top}px`;
  tooltip.innerHTML = `
    <div><b>#${fact.id}</b> ${esc(fact.subject)}</div>
    <div>${esc(fact.predicate)}: ${esc(truncate(fact.object, 140))}</div>
    <div class="tt-sub">Confidence ${(Number(fact.confidence || 0) * 100).toFixed(1)}% • ${esc(fact.bucketDate)} • ${esc(fact.source || 'unknown source')}</div>
  `;
}

function hideTimelineTooltip() {
  document.getElementById('timelineTooltip').style.display = 'none';
}

async function loadTimeline(subject) {
  let value = (subject || '').trim();
  if (!value) value = document.getElementById('timelineSubject').value.trim();
  if (!value && selectedNode && selectedNode.subject) value = selectedNode.subject;
  if (!value) {
    setModeNoteTemporary('Enter a timeline subject first.');
    return;
  }

  setTimelineDefaults();
  const from = document.getElementById('timelineFrom').value;
  const to = document.getElementById('timelineTo').value;
  const bucket = document.getElementById('timelineBucket').value || 'day';
  const includeRelated = document.getElementById('timelineShowRelated').checked;
  const minConf = parseInt(document.getElementById('confSlider').value, 10) / 100;

  document.getElementById('timelineSubject').value = value;
  document.getElementById('searchInput').value = value;
  setViewMode('timeline');
  hideBrowseResults();
  showLoading(`Loading timeline: ${value}`);

  const qs = new URLSearchParams({
    subject: value,
    bucket,
    min_confidence: String(minConf),
    related: includeRelated ? 'true' : 'false'
  });
  if (from) qs.set('from', from);
  if (to) qs.set('to', to);

  try {
    const resp = await fetch(`/api/timeline?${qs.toString()}`);
    if (!resp.ok) {
      let msg = `HTTP ${resp.status}`;
      try {
        const body = await resp.json();
        if (body?.error) msg = body.error;
      } catch (_) {}
      throw new Error(msg);
    }
    timelineData = await resp.json();
    graphData = null;
    selectedNode = null;
    renderTimeline();
  } catch (err) {
    showEmpty('Timeline Error', err.message || 'Failed to load timeline');
  }
}

function renderTimeline() {
  if (currentViewMode !== 'timeline') return;
  if (!timelineData || !Array.isArray(timelineData.buckets) || timelineData.buckets.length === 0) {
    showEmpty('No timeline data', 'No facts found in this date range for the selected subject.');
    return;
  }

  const container = document.getElementById('timelineContainer');
  const outer = document.getElementById('graphCanvas');
  const width = outer.clientWidth || window.innerWidth - 340;
  const height = outer.clientHeight || window.innerHeight;
  const showTransitions = document.getElementById('timelineShowTransitions').checked;
  const showTrend = document.getElementById('timelineShowTrend').checked;
  const showRelatedLanes = document.getElementById('timelineShowRelated').checked;
  hideTimelineTooltip();
  d3.select(container).selectAll('svg').remove();

  const margin = { top: 20, right: 36, bottom: 58, left: 150 };
  const trendBand = showTrend ? 78 : 0;
  const laneTop = margin.top + trendBand + 12;
  const laneBottom = height - margin.bottom - 6;

  const mainLower = String(timelineData.subject || '').toLowerCase();
  const facts = [];
  for (const bucket of timelineData.buckets || []) {
    const date = parseISODateUTC(bucket.date);
    if (!date) continue;
    for (const fact of bucket.facts || []) {
      facts.push({
        id: fact.id,
        subject: fact.subject || '',
        predicate: fact.predicate || '',
        object: fact.object || '',
        confidence: Number(fact.confidence || 0),
        source: fact.source || '',
        bucketDate: bucket.date,
        bucketFactCount: Number(bucket.fact_count || 1),
        date
      });
    }
  }

  const displayFacts = facts.filter(f => showRelatedLanes || String(f.subject).toLowerCase() === mainLower);
  if (displayFacts.length === 0) {
    showEmpty('No timeline data', 'No facts match the current related-lane filter.');
    return;
  }

  const relatedSubjects = Array.from(new Set(
    displayFacts
      .map(f => f.subject)
      .filter(s => String(s).toLowerCase() !== mainLower)
  )).sort((a, b) => a.localeCompare(b));
  const lanes = [timelineData.subject, ...relatedSubjects];
  const laneKeyToName = new Map(lanes.map(s => [String(s).toLowerCase(), s]));

  const minDate = parseISODateUTC(timelineData?.range?.from) || d3.min(displayFacts, d => d.date);
  const maxDate = parseISODateUTC(timelineData?.range?.to) || d3.max(displayFacts, d => d.date);
  if (!minDate || !maxDate) {
    showEmpty('No timeline data', 'Unable to parse timeline date range.');
    return;
  }
  const domainStart = minDate;
  const domainEnd = minDate.getTime() === maxDate.getTime()
    ? new Date(maxDate.getTime() + 24 * 60 * 60 * 1000)
    : maxDate;

  const x = d3.scaleTime()
    .domain([domainStart, domainEnd])
    .range([margin.left, width - margin.right]);
  const y = d3.scalePoint()
    .domain(lanes)
    .range([laneTop, laneBottom])
    .padding(0.75);

  const groupByLaneDate = d3.group(displayFacts, d => `${String(d.subject).toLowerCase()}|${d.bucketDate}`);
  for (const grouped of groupByLaneDate.values()) {
    grouped.sort((a, b) => b.confidence - a.confidence);
    const laneName = laneKeyToName.get(String(grouped[0].subject).toLowerCase()) || timelineData.subject;
    const centerY = y(laneName);
    const spread = Math.min(16, 54 / Math.max(1, grouped.length));
    grouped.forEach((d, idx) => {
      d.plotY = centerY + (idx - (grouped.length - 1) / 2) * spread;
      d.radius = 4 + Math.min(12, Math.max(1, d.bucketFactCount) * 1.35);
    });
  }
  timelineRenderedNodes = displayFacts.slice();

  const confColor = d3.scaleLinear()
    .domain([0, 0.5, 1])
    .range(['#ef4444', '#f59e0b', '#10b981'])
    .clamp(true);

  const svg = d3.select(container)
    .append('svg')
    .attr('width', width)
    .attr('height', height);

  let tickEvery = d3.timeDay.every(1);
  let tickFormat = d3.timeFormat('%b %d');
  if (timelineData.bucket === 'week') {
    tickEvery = d3.timeWeek.every(1);
    tickFormat = d3.timeFormat('%b %d');
  } else if (timelineData.bucket === 'month') {
    tickEvery = d3.timeMonth.every(1);
    tickFormat = d3.timeFormat('%b %Y');
  }

  const gridHeight = Math.max(0, laneBottom - laneTop);
  const xAxis = d3.axisBottom(x).ticks(tickEvery).tickFormat(tickFormat);
  const xGrid = d3.axisBottom(x).ticks(tickEvery).tickSize(-gridHeight).tickFormat('');
  const axisY = height - margin.bottom;
  const gridY = laneBottom;

  const grid = svg.append('g')
    .attr('class', 'timeline-grid')
    .attr('transform', `translate(0,${gridY})`)
    .call(xGrid);
  grid.select('.domain').remove();

  svg.append('g')
    .attr('class', 'timeline-lanes')
    .selectAll('line')
    .data(lanes)
    .join('line')
    .attr('x1', margin.left)
    .attr('x2', width - margin.right)
    .attr('y1', d => y(d))
    .attr('y2', d => y(d))
    .attr('stroke-width', d => String(d).toLowerCase() === mainLower ? 1.5 : 1);

  svg.append('g')
    .attr('class', 'timeline-lanes')
    .selectAll('text')
    .data(lanes)
    .join('text')
    .attr('x', margin.left - 12)
    .attr('y', d => y(d))
    .attr('text-anchor', 'end')
    .attr('alignment-baseline', 'middle')
    .attr('fill', d => String(d).toLowerCase() === mainLower ? '#f4f4f5' : '#a1a1aa')
    .text(d => d);

  const axis = svg.append('g')
    .attr('class', 'timeline-axes')
    .attr('transform', `translate(0,${axisY})`)
    .call(xAxis);
  axis.select('.domain').attr('stroke', '#52525b');
  axis.selectAll('line').attr('stroke', '#52525b');

  const defs = svg.append('defs');
  Object.entries(TIMELINE_TRANSITION_STYLE).forEach(([type, style]) => {
    const marker = defs.append('marker')
      .attr('id', `timeline-arrow-${type}`)
      .attr('viewBox', '0 -4 8 8')
      .attr('refX', 7)
      .attr('refY', 0)
      .attr('markerWidth', 6)
      .attr('markerHeight', 6)
      .attr('orient', 'auto');
    marker.append('path')
      .attr('d', 'M0,-4L8,0L0,4')
      .attr('fill', style.color);
  });

  const factByID = new Map(displayFacts.map(d => [Number(d.id), d]));
  let transitionRows = (timelineData.transitions || []).slice();
  if (!showRelatedLanes) {
    transitionRows = transitionRows.filter(tr => tr.type !== 'expanded');
  }

  const transitionPoint = (dateStr, factID, zx) => {
    const id = Number(factID || 0);
    if (id > 0 && factByID.has(id)) {
      const fact = factByID.get(id);
      return { x: zx(fact.date), y: fact.plotY };
    }
    const date = parseISODateUTC(dateStr);
    if (!date) return null;
    return { x: zx(date), y: y(timelineData.subject) };
  };

  const transitionPath = (tr, zx) => {
    const from = transitionPoint(tr.from_date, tr.from_fact, zx);
    const to = transitionPoint(tr.to_date, tr.to_fact, zx);
    if (!from || !to) return null;
    const bend = Math.max(24, Math.abs(to.x - from.x) * 0.28);
    return `M${from.x},${from.y} C${from.x + bend},${from.y} ${to.x - bend},${to.y} ${to.x},${to.y}`;
  };

  const transitionLayer = svg.append('g');
  let transitionSel = transitionLayer.selectAll('path');
  if (showTransitions) {
    transitionSel = transitionLayer.selectAll('path')
      .data(transitionRows)
      .join('path')
      .attr('class', 'timeline-transition')
      .attr('stroke', d => TIMELINE_TRANSITION_STYLE[d.type]?.color || '#71717a')
      .attr('stroke-dasharray', d => TIMELINE_TRANSITION_STYLE[d.type]?.dash || '')
      .attr('stroke-width', d => d.type === 'expanded' ? 1.8 : 2.2)
      .attr('marker-end', d => `url(#timeline-arrow-${d.type in TIMELINE_TRANSITION_STYLE ? d.type : 'expanded'})`)
      .attr('d', d => transitionPath(d, x))
      .append('title')
      .text(d => `${d.type}: ${d.description || ''}`);
  }

  const nodeLayer = svg.append('g');
  const nodeSel = nodeLayer.selectAll('circle')
    .data(displayFacts)
    .join('circle')
    .attr('class', 'timeline-node')
    .attr('cx', d => x(d.date))
    .attr('cy', d => d.plotY)
    .attr('r', d => d.radius)
    .attr('fill', d => confColor(d.confidence))
    .attr('stroke', d => selectedNode && selectedNode.id === d.id ? '#ffffff' : 'rgba(9,9,11,0.9)')
    .attr('stroke-width', d => selectedNode && selectedNode.id === d.id ? 2.4 : 1.2)
    .on('mousemove', (event, d) => showTimelineTooltip(event, d))
    .on('mouseleave', hideTimelineTooltip)
    .on('click', (event, d) => {
      selectedNode = d;
      showDetail(d);
      nodeSel.attr('stroke', n => selectedNode && selectedNode.id === n.id ? '#ffffff' : 'rgba(9,9,11,0.9)')
        .attr('stroke-width', n => selectedNode && selectedNode.id === n.id ? 2.4 : 1.2);
      showTimelineTooltip(event, d);
    });

  const trendPoints = (timelineData.confidence_trend || [])
    .map(p => ({ date: parseISODateUTC(p.date), avg: Number(p.avg || 0), raw: p }))
    .filter(p => p.date);

  let trendPathSel = null;
  let trendDotsSel = null;
  if (showTrend && trendPoints.length > 0) {
    const yTrend = d3.scaleLinear().domain([0, 1]).range([margin.top + 64, margin.top + 6]);
    const line = d3.line()
      .curve(d3.curveMonotoneX)
      .x(d => x(d.date))
      .y(d => yTrend(d.avg));

    trendPathSel = svg.append('path')
      .datum(trendPoints)
      .attr('fill', 'none')
      .attr('stroke', '#22c55e')
      .attr('stroke-width', 2)
      .attr('opacity', 0.9)
      .attr('d', line);

    const trendDotsLayer = svg.append('g');
    trendDotsSel = trendDotsLayer
      .selectAll('circle')
      .data(trendPoints)
      .join('circle')
      .attr('cx', d => x(d.date))
      .attr('cy', d => yTrend(d.avg))
      .attr('r', 3.5)
      .attr('fill', '#22c55e');
    trendDotsSel.append('title')
      .text(d => `${d.raw.date}: ${(d.avg * 100).toFixed(1)}%`);

    svg.append('text')
      .attr('x', margin.left)
      .attr('y', margin.top + 2)
      .attr('fill', '#86efac')
      .attr('font-size', 11)
      .text('Confidence Trend');
  }

  const zoomed = event => {
    const zx = event.transform.rescaleX(x);
    axis.call(d3.axisBottom(zx).ticks(tickEvery).tickFormat(tickFormat));
    axis.select('.domain').attr('stroke', '#52525b');
    axis.selectAll('line').attr('stroke', '#52525b');
    grid.call(d3.axisBottom(zx).ticks(tickEvery).tickSize(-gridHeight).tickFormat(''));
    grid.select('.domain').remove();
    nodeSel.attr('cx', d => zx(d.date));
    if (showTransitions) {
      transitionLayer.selectAll('path.timeline-transition')
        .attr('d', d => transitionPath(d, zx));
    }
    if (showTrend && trendPoints.length > 0) {
      const yTrend = d3.scaleLinear().domain([0, 1]).range([margin.top + 64, margin.top + 6]);
      const zoomLine = d3.line()
        .curve(d3.curveMonotoneX)
        .x(d => zx(d.date))
        .y(d => yTrend(d.avg));
      if (trendPathSel) trendPathSel.attr('d', zoomLine);
      if (trendDotsSel) trendDotsSel.attr('cx', d => zx(d.date));
    }
  };

  svg.call(
    d3.zoom()
      .scaleExtent([0.6, 8])
      .translateExtent([[margin.left - 80, 0], [width + 120, height]])
      .extent([[margin.left, 0], [width - margin.right, height]])
      .on('zoom', zoomed)
  );
  svg.on('dblclick.zoom', null);

  document.getElementById('loadingState').style.display = 'none';
  document.getElementById('emptyState').style.display = 'none';
  document.getElementById('controlsHelp').style.display = 'block';
  document.getElementById('statsBar').style.display = 'flex';
  document.getElementById('statNodes').textContent = displayFacts.length;
  document.getElementById('statEdges').textContent = showTransitions ? transitionRows.length : 0;
  document.getElementById('statCoocs').textContent = (timelineData.buckets || []).length;
  updateTimelineQualityPanel(timelineData, displayFacts, showTransitions ? transitionRows : [], lanes);
}

function renderGraph() {
  if (currentViewMode === 'timeline') return;
  if (!graphData || !Graph) return;

  const confMin = parseInt(document.getElementById('confSlider').value, 10) / 100;
  const timePreset = document.getElementById('timeWindow').value;
  const cutoffMs = timeCutoffForPreset(timePreset);
  const activeTypes = new Set();
  document.querySelectorAll('#edgeToggles input:checked').forEach(cb => activeTypes.add(cb.dataset.type));

  const nodes = (graphData.nodes || []).filter(n => n.confidence >= confMin && nodePassesTimeWindow(n, cutoffMs));
  const nodeIds = new Set(nodes.map(n => n.id));
  const nodeById = new Map(nodes.map(n => [n.id, n]));
  if (selectedNode && !nodeIds.has(selectedNode.id)) selectedNode = null;

  const links = [];
  (graphData.edges || [])
    .filter(e => {
      if (!nodeIds.has(e.source) || !nodeIds.has(e.target)) return false;
      if (TOGGLE_EDGE_TYPES.has(e.type)) return activeTypes.has(e.type);
      return true; // keep non-standard edge types visible
    })
    .forEach(e => links.push({
      ...e,
      _isCooc: false,
      label: nodeById.get(e.source)?.predicate || ''
    }));

  if (document.getElementById('showCoocs').checked) {
    (graphData.cooccurrences || [])
      .filter(c => nodeIds.has(c.a) && nodeIds.has(c.b))
      .forEach(c => links.push({
        source: c.a,
        target: c.b,
        type: 'cooccurrence',
        confidence: 0.25,
        count: c.count,
        _isCooc: true
      }));
  }

  document.getElementById('loadingState').style.display = 'none';
  document.getElementById('emptyState').style.display = 'none';
  document.getElementById('controlsHelp').style.display = 'block';
  document.getElementById('statsBar').style.display = 'flex';
  updateStatsBar(nodes, links);
  updateQualityPanel(nodes, links);

  const dataPayload = {
    nodes: JSON.parse(JSON.stringify(nodes)),
    links: JSON.parse(JSON.stringify(links))
  };
  if (Graph2D) {
    Graph2D.graphData(JSON.parse(JSON.stringify(dataPayload)));
  }
  applyImpactConcentricLayout();
  updateGraphStyling();
  drawLabelOverlay();

  if (autoFitPending) {
    autoFitPending = false;
    setTimeout(() => {
      if (selectedNode) return;
      if (Graph2D) {
        Graph2D.zoomToFit(700, 35);
      }
    }, 250);
  }
}

function connectedNodesFor(nodeId) {
  if (currentViewMode === 'timeline') return [];
  if (!graphData || !graphData.edges || !graphData.nodes) return [];
  const nodeById = new Map((graphData.nodes || []).map(n => [n.id, n]));
  const seen = new Set();
  const out = [];
  for (const edge of graphData.edges || []) {
    let other = null;
    if (edge.source === nodeId) other = edge.target;
    else if (edge.target === nodeId) other = edge.source;
    if (!other || seen.has(other) || !nodeById.has(other)) continue;
    seen.add(other);
    out.push(nodeById.get(other));
  }
  return out;
}

function focusNodeById(nodeId) {
  const runtimeNodes = Graph2D && Graph2D.graphData() ? (Graph2D.graphData().nodes || []) : [];
  const node = runtimeNodes.find(n => n.id === nodeId) || ((graphData && graphData.nodes) ? graphData.nodes.find(n => n.id === nodeId) : null);
  if (!node) return;
  selectedNode = node;
  showDetail(node);
  updateGraphStyling();
  if (Graph2D && Number.isFinite(node.x) && Number.isFinite(node.y)) {
    Graph2D.centerAt(node.x, node.y, 700);
    Graph2D.zoom(2.8, 700);
  }
}

async function showDetail(d) {
  const panel = document.getElementById('detailPanel');
  panel.innerHTML = `
    <div class="fact-id">#${d.id}</div>
    <div class="detail-row"><span class="detail-label">Subject</span><span class="detail-value">${esc(d.subject)}</span></div>
    <div class="detail-row"><span class="detail-label">Predicate</span><span class="detail-value">${esc(d.predicate)}</span></div>
    <div class="detail-row"><span class="detail-label">Object</span><span class="detail-value">${esc(d.object)}</span></div>
    <div class="detail-row"><span class="detail-label">Type</span><span class="detail-value"><span class="detail-badge" style="background:${FACT_TYPE_COLORS[d.type] || '#555'}22;color:${FACT_TYPE_COLORS[d.type] || '#999'}">${esc(d.type || 'unknown')}</span></span></div>
    <div class="detail-row"><span class="detail-label">Cluster</span><span class="detail-value">${esc((graphData && graphData.cluster && graphData.cluster.name) || '—')}</span></div>
    <div class="detail-row"><span class="detail-label">Confidence</span><span class="detail-value">${(d.confidence * 100).toFixed(1)}%</span></div>
    <div class="detail-row"><span class="detail-label">Facts</span><span class="detail-value">${d.fact_count || '—'}</span></div>
    <div class="detail-row"><span class="detail-label">Updated</span><span class="detail-value">${esc(d.last_updated || '—')}</span></div>
    <div class="detail-row"><span class="detail-label">Sources</span><span class="detail-value">${esc((d.source_types || []).join(', ') || '—')}</span></div>
    <div style="margin-top:10px;font-size:12px;color:var(--muted)">Loading subject facts…</div>
    <div class="detail-actions">
      <button class="btn btn-sm btn-ghost" onclick="expandFrom(${d.id})">Expand from here</button>
      <button class="btn btn-sm btn-primary" onclick="loadSelectedSubject()">Focus subject</button>
    </div>
  `;

  let facts = [];
  try {
    const resp = await fetch(`/api/facts?subject=${encodeURIComponent(d.subject || '')}`);
    if (resp.ok) {
      const payload = await resp.json();
      facts = (payload.facts || []).slice().sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
    }
  } catch (_) {}

  const factItems = facts.slice(0, 14).map(f => `
    <div style="padding:6px 0;border-top:1px solid rgba(63,63,70,0.5);">
      <div style="display:flex;align-items:center;gap:6px;flex-wrap:wrap;">
        <span class="detail-badge" style="background:${FACT_TYPE_COLORS[f.type] || '#555'}22;color:${FACT_TYPE_COLORS[f.type] || '#999'}">${esc(f.type || 'unknown')}</span>
        <span style="font-size:11px;color:var(--muted)">${((f.confidence || 0) * 100).toFixed(0)}%</span>
      </div>
      <div style="font-size:12px;color:#e4e4e7;line-height:1.45;margin-top:4px;">${esc(f.subject)} ${esc(f.predicate)} ${esc(f.object)}</div>
      <div style="font-size:11px;color:#8b8b96;margin-top:2px;">${esc(f.source || 'unknown source')}</div>
    </div>
  `).join('');

  const connected = connectedNodesFor(d.id).slice(0, 12);
  const connectedHtml = connected.map(n => `
    <button class="btn btn-sm btn-ghost" style="margin:3px 3px 0 0" onclick="focusNodeById(${n.id})">${esc(truncate(n.subject || `#${n.id}`, 26))}</button>
  `).join('');

  panel.innerHTML = `
    <div class="fact-id">#${d.id}</div>
    <div class="detail-row"><span class="detail-label">Subject</span><span class="detail-value">${esc(d.subject)}</span></div>
    <div class="detail-row"><span class="detail-label">Predicate</span><span class="detail-value">${esc(d.predicate)}</span></div>
    <div class="detail-row"><span class="detail-label">Object</span><span class="detail-value">${esc(d.object)}</span></div>
    <div class="detail-row"><span class="detail-label">Type</span><span class="detail-value"><span class="detail-badge" style="background:${FACT_TYPE_COLORS[d.type] || '#555'}22;color:${FACT_TYPE_COLORS[d.type] || '#999'}">${esc(d.type || 'unknown')}</span></span></div>
    <div class="detail-row"><span class="detail-label">Cluster</span><span class="detail-value">${esc((graphData && graphData.cluster && graphData.cluster.name) || '—')}</span></div>
    <div class="detail-row"><span class="detail-label">Confidence</span><span class="detail-value">${(d.confidence * 100).toFixed(1)}%</span></div>
    <div class="detail-row"><span class="detail-label">Facts</span><span class="detail-value">${facts.length || d.fact_count || 0}</span></div>
    <div class="detail-row"><span class="detail-label">Updated</span><span class="detail-value">${esc(d.last_updated || '—')}</span></div>
    <div class="detail-row"><span class="detail-label">Sources</span><span class="detail-value">${esc((d.source_types || []).join(', ') || '—')}</span></div>
    <div style="margin-top:10px;font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:0.08em;">Subject Facts</div>
    <div style="margin-top:6px;max-height:220px;overflow:auto;border:1px solid rgba(63,63,70,0.6);border-radius:8px;padding:0 8px;background:rgba(8,8,10,0.7);">
      ${factItems || '<div style="padding:10px 2px;color:var(--muted);font-size:12px">No subject facts found.</div>'}
    </div>
    <div style="margin-top:10px;font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:0.08em;">Connected Nodes</div>
    <div style="margin-top:6px;display:flex;flex-wrap:wrap;">${connectedHtml || '<span style="color:var(--muted);font-size:12px">No connected nodes.</span>'}</div>
    <div class="detail-actions">
      <button class="btn btn-sm btn-ghost" onclick="expandFrom(${d.id})">Expand from here</button>
      <button class="btn btn-sm btn-primary" onclick="loadSelectedSubject()">Focus subject</button>
    </div>
  `;
}

function expandFrom(factId) {
  document.getElementById('factIdInput').value = factId;
  loadGraph();
}

function loadSelectedSubject() {
  if (!selectedNode || !selectedNode.subject) return;
  loadSubject(selectedNode.subject);
}

function hideBrowseResults() {
  document.getElementById('browseResults').style.display = 'none';
}

async function searchFacts(query) {
  const el = document.getElementById('browseResults');
  if (!query || query.length < 2) {
    activeSearchNodeIDs = new Set();
    updateGraphStyling();
    hideBrowseResults();
    return;
  }

  try {
    const resp = await fetch(`/api/search?q=${encodeURIComponent(query)}&limit=15`);
    if (!resp.ok) return;
    const results = await resp.json();

    if (!results.facts || results.facts.length === 0) {
      activeSearchNodeIDs = new Set(results.matched_node_ids || []);
      updateGraphStyling();
      el.innerHTML = '<div class="browse-item" style="cursor:default"><span class="bi-text">No results</span></div>';
      el.style.display = 'block';
      return;
    }

    activeSearchNodeIDs = new Set(results.matched_node_ids || []);
    updateGraphStyling();

    el.innerHTML = results.facts.map(f =>
      `<div class="browse-item" onclick="selectSearchResult(${f.id})">
        <span class="bi-id">#${f.id}</span> ${esc(f.subject)} <span class="bi-text">${esc(truncate(f.predicate + ': ' + f.object, 62))}</span>
      </div>`
    ).join('');
    el.style.display = 'block';
  } catch (e) {
    console.error('Search error:', e);
  }
}

function selectSearchResult(factId) {
  document.getElementById('factIdInput').value = factId;
  hideBrowseResults();
  loadGraph();
}

async function loadCluster(query) {
  setViewMode('cluster');
  impactData = null;
  showLoading('Loading clusters...');
  try {
    const q = (query || document.getElementById('searchInput').value || '').trim();
    const url = q
      ? `/api/clusters?q=${encodeURIComponent(q)}&limit=${CLUSTER_LIMIT}`
      : `/api/clusters?limit=${CLUSTER_LIMIT}`;

    const resp = await fetch(url);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const payload = await resp.json();
    clusterCatalog = payload.clusters || [];
    clusterSummary = {
      total_facts: payload.total_facts || 0,
      unclustered_count: payload.unclustered_count || 0
    };
    renderClusterSidebar();

    if (clusterCatalog.length === 0) {
      graphData = { nodes: [], edges: [], cooccurrences: [], meta: { mode: 'cluster_detail' } };
      selectedNode = null;
      activeClusterId = null;
      showEmpty('No clusters found', 'Try importing more memories or rebuild clusters.');
      return;
    }

    let target = clusterCatalog[0];
    if (activeClusterId) {
      const found = clusterCatalog.find(c => Number(c.id) === Number(activeClusterId));
      if (found) target = found;
    }

    await loadClusterDetail(target.id, true);
  } catch (err) {
    clusterCatalog = [];
    renderClusterSidebar();
    showEmpty('Error', err.message);
  }
}

async function loadClusterDetail(clusterId, fromListLoad) {
  const id = Number(clusterId);
  if (!id || Number.isNaN(id)) return;

  activeClusterId = id;
  renderClusterSidebar();
  if (!fromListLoad) {
    setViewMode('cluster');
    showLoading('Loading cluster details...');
  }

  try {
    const resp = await fetch(`/api/clusters/${id}?limit=${CLUSTER_DETAIL_LIMIT}`);
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    graphData = await resp.json();
    selectedNode = null;
    autoFitPending = true;

    if (!graphData.nodes || graphData.nodes.length === 0) {
      showEmpty('Cluster is empty', 'This cluster currently has no visible facts.');
      return;
    }

    if (graphData.cluster && graphData.cluster.name) {
      document.getElementById('searchInput').value = graphData.cluster.name;
    }

    renderGraph();
  } catch (err) {
    showEmpty('Error', err.message);
  }
}

function highlightSearch(query) {
  if (!Graph || !graphData) return;
  if (!query || query.trim().length < 2) {
    activeSearchNodeIDs = new Set();
  }
  updateGraphStyling();
}

document.getElementById('depthSlider').addEventListener('input', e => {
  document.getElementById('depthValue').textContent = e.target.value;
});

document.getElementById('confSlider').addEventListener('input', e => {
  document.getElementById('confValue').textContent = `${e.target.value}%`;
  if (currentViewMode === 'timeline' && timelineData) renderTimeline();
  else if (graphData) renderGraph();
});

document.getElementById('confSlider').addEventListener('change', () => {
  if (currentViewMode === 'timeline' && timelineData) loadTimeline();
});

document.getElementById('timeWindow').addEventListener('change', () => {
  if (graphData) renderGraph();
});

document.querySelectorAll('#edgeToggles input').forEach(cb => {
  cb.addEventListener('change', () => {
    if (graphData) renderGraph();
  });
});

['showCoocs', 'showLabels', 'showArrows', 'impactConcentric'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    if (graphData) renderGraph();
  });
});

['timelineShowTransitions', 'timelineShowTrend'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    if (currentViewMode === 'timeline' && timelineData) renderTimeline();
  });
});

document.getElementById('timelineShowRelated').addEventListener('change', () => {
  if (currentViewMode === 'timeline') loadTimeline();
});

['timelineBucket', 'timelineFrom', 'timelineTo'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => {
    if (currentViewMode === 'timeline' && timelineData) loadTimeline();
  });
});

document.getElementById('timelineSubject').addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    loadTimeline(e.target.value.trim());
  }
});

document.getElementById('searchInput').addEventListener('input', e => {
  const q = e.target.value.trim();
  clearTimeout(searchDebounce);
  searchDebounce = setTimeout(() => {
    searchFacts(q);
    highlightSearch(q);
  }, 300);
});

document.getElementById('searchInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') {
    const q = e.target.value.trim();
    hideBrowseResults();
    if (currentViewMode === 'impact') loadImpact(q);
    else if (currentViewMode === 'timeline') {
      if (q) document.getElementById('timelineSubject').value = q;
      loadTimeline(q);
    } else loadCluster(q);
  }
  if (e.key === 'Escape') {
    hideBrowseResults();
  }
});

document.getElementById('factIdInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') loadGraph();
});

document.addEventListener('click', e => {
  const searchInput = document.getElementById('searchInput');
  const browseResults = document.getElementById('browseResults');
  if (!searchInput.contains(e.target) && !browseResults.contains(e.target)) {
    hideBrowseResults();
  }
});

window.addEventListener('load', () => {
  buildTypeLegend();
  setTimelineDefaults();
  setViewMode('cluster');
  setQualityStatus('Initializing graph explorer...');

  setTimeout(() => {
    initGraph();

    const params = new URLSearchParams(window.location.search);
    if (params.get('fact_id')) {
      document.getElementById('factIdInput').value = params.get('fact_id');
      if (params.get('depth')) {
        document.getElementById('depthSlider').value = params.get('depth');
        document.getElementById('depthValue').textContent = params.get('depth');
      }
      loadGraph();
    } else if (params.get('subject')) {
      loadSubject(params.get('subject'));
    } else {
      loadCluster('');
    }

    fetch('/api/stats')
      .then(r => r.json())
      .then(s => {
        document.getElementById('dbFacts').textContent = s.facts?.toLocaleString() || '—';
        document.getElementById('dbMemories').textContent = s.memories?.toLocaleString() || '—';
        document.getElementById('dbEdges').textContent = s.edges?.toLocaleString() || '—';
        document.getElementById('dbConf').textContent = s.avg_confidence ? `${(s.avg_confidence * 100).toFixed(0)}%` : '—';
      })
      .catch(() => {});
  }, 180);
});
</script>
</body>
</html>
